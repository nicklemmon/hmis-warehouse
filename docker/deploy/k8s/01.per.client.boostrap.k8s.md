# Bootstrap a single client environment

I started with
[Instructions](https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html)
to create this file.

## Set up local environemnt

Set the client and environment to what you want instead of `qa`. Also set
the version to whatever you'll push to ECR

        export AWS_PROFILE=openpath
        export CLIENT=qa
        export ENVIRONMENT=production
	export NAMESPACE=$CLIENT-$ENVIRONMENT
	export VERSION=0.0.3

## Make namespace

       cat k8s/namespace.yml | envsubst | kubectl apply -f -

       echo set the default namespace
       kubectl config set-context --current --namespace=$NAMESPACE

# Make a service account (k8s side)

Fuzzy why we need this. It think it's just setting permissions on what the
ingree controllers can do.

Create a Kubernetes service account named alb-ingress-controller in the kube-system namespace, a cluster role,
and a cluster role binding for the ALB Ingress Controller to use with the
following command:

       cat k8s/rbac-role.yml | envsubst | kubectl apply -f -

## Make Service Account (AWS side)

Create an IAM role for the ALB ingress controller and attach the role to the
service account created in the previous step. If you didn't create your cluster
with eksctl, then use the instructions on the AWS Management Console or AWS CLI
tabs.

<pre>

eksctl create iamserviceaccount \
    --region us-east-1 \
    --name alb-ingress-controller \
    --namespace $NAMESPACE \
    --cluster openpath \
    --attach-policy-arn arn:aws:iam::153758321681:policy/ALBIngressControllerIAMPolicy \
    --override-existing-serviceaccounts \
    --approve

</pre>

# Deploy the ALB Ingress Controller

This object allows us to create a k8s ingress that will auto-create a load
balancer.

        cat k8s/alb-ingress-controller.yml | envsubst | kubectl apply -f -


        kubectl cluster-info
        kubectl get namespace


## Add environment

https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/

        ./make_secrets.rb ${NAMESPACE} > secrets.yml
        kubectl apply -f secrets.yml -n ${NAMESPACE}

        kubectl get secrets
        kubectl describe secrets ${NAMESPACE}-env

## Deploy the app

	echo set first version to deploy that should be on ECR
	export VERSION=0.0.3

	echo This just deploys nginx initially pending the first real deployment
	export IMAGE=nginx:latest
        cat k8s/deployment.yml | envsubst | kubectl apply -f -
-----> WIP: rename deployment to have namespace in it?
-----> WIP: delayed jobs container
-----> WIP: pod affinities and anti-affinites
-----> WIP: cron?
-----> WIP: resource specs
-----> WIP: logging
-----> WIP: IP address binding (elastic IPs to nodes)
-----> WIP: network segregation by client?
        kubectl get deployments

        kubectl exec -it warehouse-web-deployment<TAB> -- /bin/sh

	echo make those deployed pods accessible internal to cluster
        cat k8s/service.yml | envsubst | kubectl apply -f -

	echo tie the service to the external world
        cat k8s/ingress.yml | envsubst | kubectl apply -f -
-----> WIP: certificate with alb
-----> WIP: alb on 443
-----> WIP: logging
-----> WIP: sticky

        kubectl get pods
        kubectl get services

------> WIP: provision CNAME records for new load balancer
------> WIP: Enable cluster logging
        kubectl utils update-cluster-logging --region=us-east-1 --cluster=openpath
